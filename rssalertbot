#!/usr/bin/env python
"""
RSS feed monitoring robot.

"""

import argparse
import base64
import datetime
import hipchat
import feedparser
import json
import logging
import os
import pytz
import re
import requests
import sys
import html2text
import zc.lockfile
import signal

from dateutil       import parser as dateparser
from html.parser    import HTMLParser
from mailer         import Mailer, Message
from pkg_resources  import get_distribution, DistributionNotFound
from slackclient    import SlackClient

__author__    = 'Michael Stella <michael@jwplayer.com>'

try:
    __version__ = get_distribution('rssalertbot').version
except DistributionNotFound:
    # package is not installed
    __version__ = '0.1.0-alpha'

BOT_USERNAME = 'RSS Alert Bot'

KEYS_GREEN  = ('Completed', 'Resolved', 'RESOLVED')
KEYS_YELLOW = ('Identified', 'Monitoring', 'Update', 'Mitigated', 'Update', 'Scheduled')

LOCK_FILE = '/var/lock/rssalertbot.lock'

FEED_TIMEOUT = 10

BOGUS_TIMEZONES = {
    'PST': '-0800',
    'PDT': '-0700',
    'MST': '-0700',
    'MDT': '-0600',
    'CST': '-0600',
    'CDT': '-0500',
    'EST': '-0500',
    'EDT': '-0400',
}

logging.basicConfig(level=logging.ERROR,
                    format='%(levelname)-7s [%(module)s.%(funcName)s:%(lineno)d] %(message)s')
log = logging.getLogger()


def timeout(func, args=(), kwargs={}, timeout_duration=FEED_TIMEOUT, default=None):
    class TimeoutError(Exception):
        pass

    def handler(signum, frame):
        raise TimeoutError()

    # set the timeout handler
    signal.signal(signal.SIGALRM, handler)
    signal.alarm(timeout_duration)
    try:
        result = func(*args, **kwargs)
    except TimeoutError as e:
        result = default
    finally:
        signal.alarm(0)

    return result


class Feed:
    """Base class for feeds"""
    group = "FeedBot"

    enable_slack    = False
    enable_hipchat  = False
    enable_email    = False
    enable_log      = False

    hipchat_colors  = {}
    hipchat_match_body = False

    slack_colors = {}
    slack_match_body = False
    slack_force_color = None

    username = None
    password = None

    def __init__(self, cfg, group, feed, url):
        self.feed = feed
        self.url  = url

        outputs = cfg['outputs']
        self.state_path = cfg['state_path']

        if 'hipchat' in outputs:
            self.enable_hipchat = outputs['hipchat']['enabled']
            self.hipchat_room   = outputs['hipchat']['room']
            self.hipchat_token  = outputs['hipchat']['token']

        if 'email' in outputs:
            self.enable_email   = outputs['email']['enabled']
            self.email_target   = outputs['email']['to']
            self.email_from     = f"{group['name']} Feeds <{outputs['email']['from']}>"
            self.email_server   = outputs['email']['server']

        if 'log' in outputs:
            self.enable_log     = outputs['log']['enabled']

        if 'slack' in outputs:
            self.enable_slack   = outputs['slack']['enabled']
            self.slack_channel  = outputs['slack']['channel']
            self.slack_token    = outputs['slack']['token']

        # do the global notification disable
        if cfg.get('no_notify', False):
            log.debug("Note: notifications disabled")
            self.enable_email = False
            self.enable_hipchat = False

        self.group = group['name']

        # configure fetch user/password
        if 'username' in group:
            self.username = group['username']
        if 'password' in group:
            self.password = group['password']

        if 'outputs' in group:
            # configure email output
            if self.enable_email and 'email' in group['outputs']:
                # enable/disable email here, default = false
                self.enable_email = group['outputs']['email'].get('enabled', False)

                if 'to' in group['outputs']['email']:
                    self.email_target = group['outputs']['email']['to']
                if 'from' in group['outputs']['email']:
                    self.email_from = group['outputs']['email']['from']
            else:
                self.enable_email = False

            # configure hipchat output
            if self.enable_hipchat and 'hipchat' in group['outputs']:
                if 'room' in group['outputs']['hipchat']:
                    self.hipchat_room = group['outputs']['hipchat']['room']
                if 'colors' in group['outputs']['hipchat']:
                    self.hipchat_colors = group['outputs']['hipchat']['colors']
                if 'match_body' in group['outputs']['hipchat']:
                    self.hipchat_match_body = group['outputs']['hipchat']['match_body']
            else:
                self.enable_hipchat = False

            # configure slack output
            if self.enable_slack and 'slack' in group['outputs']:
                if 'channel' in group['outputs']['slack']:
                    self.slack_channel = group['outputs']['slack']['channel']
                if 'colors' in group['outputs']['slack']:
                    self.slack_colors = group['outputs']['slack']['colors']
                if 'force_color' in group['outputs']['slack']:
                    self.slack_force_color = group['outputs']['slack']['force_color']
                if 'match_body' in group['outputs']['slack']:
                    self.slack_match_body = group['outputs']['slack']['match_body']
            else:
                self.enable_slack = False

        self._previous_date = None

        self.datafile = os.path.join(cfg['state_path'], f'last.{self.feed}.dat')

        log.debug(f" url: {self.url}")
        log.debug(f" datafile: {self.datafile}")


    @property
    def previous_date(self):
        if not self._previous_date:
            # read the previous date from our data file
            try:
                with open(self.datafile, 'rb') as f:
                    self._previous_date = dateparser.parse(f.read().strip())
            except:
                self._previous_date = datetime.datetime.utcnow().replace(tzinfo=pytz.utc) - datetime.timedelta(days=1)

        return self._previous_date


    def save_date(self, new_date):
        """save the date, as UTC always"""
        with open(self.datafile, 'w') as f:
            f.write(str(new_date.astimezone(pytz.utc)))


    def entries(self):
        """Fetch and return a list of entries"""
        headers = {}
        if self.username and self.password:
            creds = f'{self.username}:{self.password}'.encode('utf-8')
            headers['Authorization'] = f'Basic {base64.urlsafe_b64encode(creds)}'

        try:
            rsp = requests.get(self.url, headers=headers)
            data = feedparser.parse(rsp.text)
            if not data:
                log.error(f"Error: no data recieved for feed {self.feed}")
                return []
            return data.entries
        except Exception as e:
            log.error(f"Error or timeout while fetching feed {self.feed}: {e}")
            return []


    def process(self):
        """Fetch and process this feed"""

        now = datetime.datetime.utcnow().replace(tzinfo=pytz.utc)
        log.debug(f"{self.feed} previous date: {self.previous_date}")

        new_date = None
        for entry in self.entries():
            # fix some bogus timezones
            m = re.search(' ([PMCE][DS]T)$', entry.published)
            if m:
                entry.published = entry.published.replace(m.group(1),
                                                          BOGUS_TIMEZONES[m.group(1)])

            date = dateparser.parse(entry.published)

            # store the date from the first entry
            if not new_date or date > new_date:
                new_date = date

            # skip anything that's stale
            if date <= (now - datetime.timedelta(days=1)):
                continue

            # and anything before the previous date
            if date <= self.previous_date:
                continue

            self.alert(entry)

        if not new_date:
            new_date = now

        self.save_date(new_date)


    def alert(self, entry):
        self.alert_log(entry)
        self.alert_email(entry)
        self.alert_hipchat(entry)
        self.alert_slack(entry)


    def alert_email(self, entry):
        """Sends alert via email"""

        if not self.enable_email:
            return

        description = strip_html(entry.description)

        smtp = Mailer(host=self.email_server)
        message = Message(charset="utf-8", From=self.email_from, To=self.email_target,
                          Subject = f"{self.group} Alert: ({self.feed}) {entry.title}")
        message.Body = f"Feed: {self.feed}\nDate: {entry.published}\n\n{description}"
        message.header('X-Mailer', 'rssalertbot')
        smtp.send(message)


    def alert_hipchat(self, entry, color=None):
        """Sends alert to hipchat"""
        if not self.enable_hipchat:
            return

        # the string we'll match against for coloring the message
        # - it might be both title *and* description
        matchstring = entry.title
        if self.hipchat_match_body:
            matchstring += entry.description

        # attempt to match the provided strings, in addition to the standards
        # first we do a regex to find the first occurrance, assuming that the
        # most recent status in the entry will be at the beginning, then
        # match that against the color list
        if self.hipchat_colors:
            matches = '(' + '|'.join(self.hipchat_colors.keys()) + ')'
            m = re.search(matches, matchstring)
            if m:
                for (s, c) in self.hipchat_colors.items():
                    if s in m.groups(1):
                        color = c
                        break

        # if color isn't set already, try some defaults
        if not color:
            color = guess_color(matchstring)['hipchat_color']

        hipster = hipchat.HipChat(token=self.hipchat_token)

        message = '<b>{feed}</b> {date}: {title}<br>{body}'.format(
            feed=self.feed,
            date=entry.published,
            title=entry.title,
            body=entry.description)

        try:
            hipster.message_room(self.hipchat_room, self.group, message,
                                 message_format='html', color=color, notify=True)
        except Exception as e:
            log.error(f"Error contacting Hipchat for feed {self.feed}: {e}")


    def alert_log(self, entry):
        """Sends alert to logfile"""
        if not self.enable_log:
            return

        log.warning(f"({self.feed}) {entry.published}: {entry.title}")
        log.debug(f"{entry.description}")

    def alert_slack(self, entry, color=None):
        """Sends alert to slack"""

        if not self.enable_slack:
            return

        matchstring = entry.title
        if self.slack_match_body:
            matchstring += entry.description

        # use the provided color
        if self.slack_force_color:
            color = self.slack_force_color

        # guess color
        elif self.slack_colors:
            matches = '(' + '|'.join(self.slack_colors.keys()) + ')'
            m = re.search(matches, matchstring)
            if m:
                for (s, c) in self.slack_colors.items():
                    if s in m.groups(1):
                        color = c
                        break

        # if color isn't set already, try some defaults
        if not color:
            color = guess_color(matchstring)['slack_color']

        # cleanup description to get it supported by slack - might figure out something more elegant later
        desc = html2text.html2text(entry.description)
        desc = desc.replace('**', '*')
        desc = desc.replace('\\', '')
        desc = desc.replace('<', '&lt;')
        desc = desc.replace('>', '&gt;')
        desc = desc.replace('&', '&amp;')

        attachments = [
            {
                "title": "{} {}\n{}".format(self.feed, entry.published, entry.title),
                "text": desc,
                "mrkdwn_in": [
                    "title",
                    "text"
                ],
                "color": color
            }
        ]

        try:
            sc = SlackClient(self.slack_token)
            sc.api_call(
                "chat.postMessage",
                channel=self.slack_channel,
                attachments=attachments,
                icon_emoji=':information_source:',
                as_user=False,
                username=BOT_USERNAME
            )

        except Exception as e:
            log.error(f"Error contacting Slack for feed {self.feed}: {e}")


class HTMLStripper(HTMLParser):
    def __init__(self):
        self.reset()
        self.fed = []
        self.strict = False
        self.convert_charrefs = True

    def handle_data(self, d):
        self.fed.append(d)

    def get_data(self):
        return ''.join(self.fed)


def strip_html(html):
    s = HTMLStripper()
    s.feed(html)
    return s.get_data()


def guess_color(matchstring):
    """Try to guess the color of the message"""

    for key in KEYS_GREEN:
        if key in matchstring:
            return {"hipchat_color": "green", "slack_color": "good"}

    for key in KEYS_YELLOW:
        if key in matchstring:
            return {"hipchat_color": "yellow", "slack_color": "warning"}

    return {"hipchat_color": "red", "slack_color": "danger"}


def main(cfg):
    for group in cfg['feedgroups']:
        log.info(f"Fetching feeds for {group['name']}")

        for f in group['feeds']:
            log.info(f" Fetching feed '{f['name']}'")
            feed = Feed(cfg, group, f['name'], f['url'])
            timeout(feed.process, timeout_duration=int(opts.feed_timeout))


def readconfig(cfgfile):
    """Read config file"""
    log.debug(f"Reading config from {cfgfile}")
    try:
        cfg = None
        with open(cfgfile, 'r') as f:
            cfg = json.loads(f.read())
        return cfg
    except IOError as e:
        log.error(f"Can't open config file: {e}")
        sys.exit(-1)


if __name__ == '__main__':
    argparser = argparse.ArgumentParser()
    argparser.add_argument('-c', '--config', type=str, default="config.json",
                           help="config file (default: ./config.json)")
    argparser.add_argument('-l', '--lock', type=str, default=LOCK_FILE,
                           help=f"lock file (default: {LOCK_FILE})")
    argparser.add_argument('-t', '--feed_timeout', type=str, default=FEED_TIMEOUT,
                           help=f"feed processing timeout in seconds (default: {FEED_TIMEOUT})")
    argparser.add_argument('--state_path', type=str,
                           help="state path (default: config file 'state_path')")
    argparser.add_argument('--no-notify', action='store_true',
                           help="Disable all notifications globally")
    argparser.add_argument('-v', action='count',
                           help="Verbose - repeat for increased debugging")
    argparser.add_argument('--version',  action='version',
                           version=f'%(prog)s {__version__}')

    opts = argparser.parse_args(sys.argv[1:])

    # handle lockfile
    try:
        lock = zc.lockfile.LockFile(opts.lock)
    except zc.lockfile.LockError:
        print("Another process is running - exiting")
        sys.exit(1)

    if opts.v:
        if opts.v >= 3:
            log.setLevel(logging.DEBUG)
        elif opts.v == 2:
            log.setLevel(logging.INFO)
        elif opts.v == 1:
            log.setLevel(logging.WARNING)

    cfg = readconfig(opts.config)

    if opts.no_notify:
        cfg['no_notify'] = True

    if 'state_path' not in cfg:
        cfg['state_path'] = ''

    # allow command-line override
    if opts.state_path:
        cfg['state_path'] = opts.state_path

    if cfg['state_path'] and not os.path.isdir(cfg['state_path']):
        os.makedirs(cfg['state_path'])
        if not os.path.isdir(cfg['state_path']):
            log.error(f"State path '{cfg['state_path']}' does not exist and we can't create it")
            sys.exit(-1)

    main(cfg)
